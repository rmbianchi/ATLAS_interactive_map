/* 

Interactive ATLAS Collaboration world map 

MAIN JAVASCRIPT FILE

Author:        Riccardo Maria BIANCHI <rbianchi-at-cern.ch>
First version: 15 Apr 2014
Update:        02 Oct 2014

v. 6

*/


	// Main mapping script
		
	
	/* 
	* /////////
	* TODO:
	* /////////
	* 
	* - make "Sources" text underlined (like a link)
	* - try to make all fonts dark grey, instead of black
	* - make the inst's box start from the inst's circle on the map (you could use dot's cx,cy)
	* - style the brush, perhaps like a magnifying glass, and maybe make it fixed-size 
	*   (for the latter see here: http://stackoverflow.com/questions/12354729/d3-js-limit-size-of-brush)
	* - set the height of the scroll-list the same of the size of the map
	* - make the scroll bars of the scroll list visible, so users kknow they have to scroll down the list to see more institutions
	* - make the line of the key's labels pointers thinner
	* - try to place the copyright label vertically on the left side, and smaller
	* - Ceci's suggestion: make the institutions' bubble on the right list the same color of their belonging country: in this way we could differentiate them based on the legend
	*/
	
	
	
	
	/////////
	// DEFINE DEFS and PATTERNS FOR LATER USE
	/////////
	// we want to add this snippet to the body
	/*
	<svg id="mySvg" width="80" height="80">
	      <defs id="mdef">
	        <pattern id="image" x="0" y="0" height="40" width="40">
	          <image x="0" y="0" width="40" height="40" xlink:href="http://www.e-pint.com/epint.jpg"></image>
	        </pattern>
	  </defs>
	*/
	/*
	defs = d3.select("body").append("svg")
	           .append("defs").attr("id", "mdef")
			   .append("pattern")
			   .attr("id", "image")
			   .attr("x", 0)  
			   .attr("y", 0)
			   .attr("height", 30)  
			   .attr("width", 30)
			   .append("image")
			   .attr("x", 0)  
			   .attr("y", 0)
			   .attr("height", 30)  
			   .attr("width", 30)
			   .attr("xlink:href", "http://png-4.findicons.com/files/icons/2711/free_icons_for_windows8_metro/26/university.png");
	*/
	
	
	
	
	// Store our map dimensions
	mapDim = {
	    width: 938,
		height: 400,
	    //innerRadius: 50,
	    //outerRadius: 150,
	    labelRadius: 50
	}
	
	
	
    var m_width = $("#map").width(),
                  width = mapDim.width,
                  height = mapDim.height,
                  country,
                  state;
			
	
	// Defining the SVG container (i.e. the SVG Viewport)
    var svg = d3.select("#map").append("svg")
        .attr("preserveAspectRatio", "xMidYMid")
        .attr("viewBox", "0 0 " + width + " " + height)
        .attr("width", m_width)
        .attr("height", m_width * height / width)
		.attr("id", "svg-container");

	// add a transparent background to catch mouse events:
    svg.append("rect")
        .attr("class", "background")
        .attr("width", width)
        .attr("height", height)
        .on("click", country_clicked) //to link the "sea" to the reset function
		;


	
	
	
	
	/////////
	// DEFING SCALES FOR CHOROPLETH MAP
	/////////
	
	// set quantize color scale for the colorpleth map
	var quantize = d3.scale.quantize();
	var quantile = d3.scale.quantile();

    //// set a threshold color scale
	
	//color ranges
	
	// color ranges obtained on ColorBlend (http://meyerweb.com/eric/tools/color-blend/)
	// setting as start point the hue used as background countries in CSS above, and as end point
	// the new official ATLAS blue: #0B80C3
	// from #cde to ATLAS blue, through 6 mid-tones
	meyer8 = ["#CCDDEE", "#B0D0E8", "#95C2E2", "#79B5DC", "#5EA8D5", "#429BCF", "#278DC9", "#0B80C3"] 
	// from #cde to ATLAS blue, through 10 mid-tones
	meyer10 = ["#CCDDEE", "#BAD5EA", "#A9CCE6", "#97C4E2", "#86BBDE", "#74B3DA", "#63AAD7", "#51A2D3", "#4099CF", "#2E91CB", "#1D88C7", "#0B80C3"] 
	/* custom color series.
	 * the first color is the base color, the second one is the new official ATLAS blue. 
	 * the purpose is to have a huge gap between the base color of the first bin, and the second bin: 
	 * in this way the difference is grater between countries who are ATLAS members and the others
	*/
	ric5 = [ "#cee5f3", "#0B80C3", "#09669C", "#064D75", "#04334e"];
	ric5n = [ "#cee5f3", "#90d3f9", "#0B80C3", "#064163", "#021622" ]; // picked from the gradient generated by 0t0255.com with #0B80C3
	
	var colorScale = d3.scale.threshold()
	    //.domain([0., 1.e-8, 1e-7, 1e-6, 3e-6, 6e-6, 1e-5, 3e-5]) // 6 mid-points
		//.domain([0., 1.e-9, 5e-9, 1e-8, 5e-7, 1e-7, 5e-7, 1e-6, 5e-6, 1e-5, 5e-5, 2e-4]) // 10 mid-points
		//.range(["#6cb2db", "#3b99cf", "#08669c", "#064c75", "#04334e", "#021927"]);
		//.range( meyer8 )
		//.range( meyer10 )
		.range( ric5n )
		;
	
	
	
	// COLOR LEGEND
	// A position encoding for the key only.
	var xScale = d3.scale.log()
			    //.domain([0, 5e-5])
			    .range([0, 240]); // length of the rectangle

	var xAxis = d3.svg.axis()
			    .scale(xScale)
			    .orient("bottom")
			    .tickSize(13)
			    //.tickValues(colorScale.domain()) // set later, after the domain initialization
				.tickValues([]);
				;
				
		
	// a map container (not a geographical map! but a dictionary-like) to store couples (country_code, involvment_rate)
	var rateById = d3.map();
	
	// variable to store if we are in "zoom" mode over a country, or not
	var zoom_mode = 0;
	
	
	// Loading the rate data, and set the max and min for the scale.
	// we have to use queue.await(function_name) because the dataset with rates per country has to be loaded
	// before calculating max and min to be used for setting the domain() of the quantize scale
	queue()
	    .defer(d3.csv, "data/members_population_rate.csv", function(d) { rateById.set(d.country_code, +d.rate ); })
		.await(maxRate);
	
	function maxRate() {
		//alert("map values: "+rateById.values());
		var maxRate = d3.max(rateById.values());
		var minRate = d3.min(rateById.values());
		//alert("max: "+maxRate + " - min: " + minRate);
	
	
	    // Set the "quantize scale"
	    //quantize.domain([minRate, maxRate]); // maxRate is far toooo high compared to all the others: it's an outlier (Azerbaijan)
		quantize.domain([minRate, 0.00001]);
	    quantize.range(d3.range(9).map(function(i) { return "q" + i + "-9"; }));
		
		
		/* set the "quantile scale"
		 * explanations:  http://stackoverflow.com/questions/10579944/how-does-d3-scale-quantile-work
		 * we feed the uantile input domain with the whole set of rate values
		*/
  	  	quantile.domain(rateById.values());
  	  	// a test output range
	  	// quantile.range(['green', 'purple', 'red']);
	  	// set the quantile output range using the new darker ATLAS blue (#0b80c3) 
	  	// on kolorwheel.com and taking the shades they propose based on that
	  	quantile.range(["#6cb2db", "#3b99cf", "#08669c", "#064c75", "#04334e", "#021927"]);
		
		
		// set the "threshold scale"
		//colorScale.domain([0., minRate, 1e-7, 1e-6, 3e-6, 6e-6, 1e-5, 3e-5]) // 8 bins
		var minDomain = minRate - (minRate*10./100.); // set the minimum at minRate - 10%
		var maxDomain = maxRate + (maxRate*10./100); // set the maximum at maxRate + 10%
		//alert ("minDomain: "+minDomain + " - maxDomain: " + maxDomain);
		colorScale.domain([minDomain, 1e-6, 2e-6, 1e-5]); // 5 bins
		
		// set the x axis of the legend
		xAxis.tickValues(colorScale.domain());
		 
		// LEGEND
		
		xScale.domain( [minDomain, maxDomain] ); // set the domain for the x scale of the legend
		
		
		
		
		
		// Please notice: "g" is the standard DOM selector for svg elements which need to be grouped
		
		
		var gg = svg.append("g")
		            .attr("id", "key-container")
		            .attr("class", "key")
		            .attr("transform", "translate(20,340)");

		gg.selectAll("rect")
		    .data(colorScale.range().map(function(d, i) {
		        //x0 = i ? xScale(colorScale.domain()[i - 1]) : xScale.range()[0];
		        //x1 = i < colorScale.domain().length ? xScale(colorScale.domain()[i]) : xScale.range()[1];
		        //z = d;
				//alert (d+": " + x0 + " - " +x1);
		      return {
		        x0: i ? xScale(colorScale.domain()[i - 1]) : xScale.range()[0],
		        x1: i < colorScale.domain().length ? xScale(colorScale.domain()[i]) : xScale.range()[1],
		        z: d
		      };
		    }))
		  .enter().append("svg:rect")
		    .attr("height", 8)
		    .attr("x", function(d) { return d.x0; })
		    .attr("width", function(d) { return d.x1 - d.x0; })
		    .style("fill", function(d) { return d.z; });

		// appending the text labels to the key
		gg.call(xAxis).append("svg:text")
		    .attr("class", "legend-caption")
		    .attr("y", -6)
		    .text("ATLAS members per inhabitants");

			
		gg.call(xAxis).append("svg:text")
			 		  .attr("class", "key-label")
			 		  .attr("x", -12)
			 		  .attr("y", 50)
			 		  .text("1 ATLAS member in every million people")
			 		  ;
			
		gg.call(xAxis).append("svg:text")
			 		  .attr("class", "key-label")
			 		  .attr("x", 206)
			 		  .attr("y", 50)
			 		  .text("1 ATLAS member in every hundred thousand people")
			 		  ;
		
	}
	
	
	// adding the two pointers to the key's labels
	svg.append("svg:path")
		  			  .attr("class", "key-pointer")
		  			  .style("fill", "none")
		  			  .style("stroke", "black") // TODO: make the line thinner
		  			  .attr("marker-end", "url(#circ)") // FIXME: it does not show up!
		  			  .attr("d", function(d) {
		  				  return "M" + 380 + "," + 380 + "L" + 225 + "," + 380 + " " + 215 + "," + 367;
		  			  });
	svg.append("svg:path")
		  			  .attr("class", "keypointer")
		  			  .style("fill", "none")
		  			  .style("stroke", "black")
		  			  .attr("marker-end", "url(#circ)") // FIXME: it does not show up!
		  			  .attr("d", function(d) {
		  				  return "M" + 7 + "," + 380 + "L" + 125 + "," + 380 + " " + 125 + "," + 367;
		  			  });
	
	
	
	
	// add a div to show the country tooltip
	// we append it to the "map" div because it's a div itself
	//
	// NOT USED ANYMORE
	//
	/*
	var div = d3.select("#map").append("div")   
		  .attr("class", "map-country-tooltip")               
		  .style("opacity", 0);
	*/
	
	
		  
	// add a labels to show the text labels
	//
	// NOT USED
	/*
	var labels = d3.select("#map").append("labels")   
	  		  //.attr("class", "tooltip")               
	  		  //.style("opacity", 0)
			  ;
	*/
	
	// add an hidden div to show the text about the sources
	//
	var sources_tooltip = d3.select("#map").append("div")   
	  		  .attr("class", "sources-tooltip")               
	  		  .style("opacity", 0)
			  ;
	
	
			  
	/*var scroll_list = d3.select("body").append("div")
			  .attr("class", "scrollingContainer")
			  .attr("id", "scroll_list2");  
	*/		  
	var scroll_list_div = d3.select("#div-b-right-bubblescrolllist").append("div")
			  .attr("class", "scrollingContainer")
			  .attr("id", "scroll_list")
			  ;
			  
	// FIXME: I want to set the height of the scroll-list like that onf the map
	//var list_height = $("#div-b-right-bubblescrolllist").height(),
	//	                    height = mapDim.height;
	


	

	
		// add a button to toggle institutions' dots
		// we append it to the main svg container, because
		// it's a svg element itself
		//
		// NOT USED NOW
		//
		/*
	  	var myCircle=svg.append("circle")
	  		  .attr("cx",60)
	  		  .attr("cy",60)
	  		  .attr("fill", "#0B80C3")
			  //.style("fill", "url(#image)")
			  .style("opacity", 0.7)
	  		  .attr("r",20);
			  
			  myCircle.on("mouseover", function() {
			    d3.select(this)
			    .transition().duration(300)
			    .style("opacity", 1.)
				.attr("r", 30);
			  })
			  .on("mouseout", function() {
			    d3.select(this)
			    .transition().duration(300)
			    .style("opacity", 0.7)
				.attr("r", 20);	
			   })
			  .on("click", toggle_institutions)	
			   .call(d3.behavior.drag().on("drag", move));	    
			  ;
		*/
	
	var buttonInsts = d3.select("#map").append("div")
			.attr("class","institutions-button-greyed")
			.style("left", 110+"px")
			.style("top", "21%")
		    .on("click", toggle_institutions) // that will be changed in toggle_institutions() itself
			.attr("data-toggle", "tooltip")
			.attr("data-placement","right")
			.attr("id", "insts-toggle-button")
			.attr("title", "Click to display / hide the dots representing the ATLAS Institutions") // for tooltip
			.attr("data-original-title", "Click to display / hide the dots representing the ATLAS Institutions") // for tooltip
			.attr("rel","tooltip") // for tooltip
			;

	var buttonCountries = d3.select("#map").append("div")
					.attr("class","countries-button")
					.style("left", 110+"px")
					.style("top", "15%")
				    .on("click", null) // that will be changed in toggle_institutions()
					.attr("data-toggle", "tooltip")
					.attr("data-placement","right")
					.attr("id", "countries-toggle-button")
					.attr("title", "Click to display / hide the ATLAS Countries") // for tooltip
					.attr("data-original-title", "Click to display / hide the ATLAS Countries") // for tooltip
					.attr("rel","tooltip") // for tooltip
					;


			
	// init the tooltip for the icon button
	//$(".institutions-button").tooltip();		
	////$("#insts-button-tooltip").tooltip();	
	
	
	// add a text line for "Sources"
	// we append it to the "map" div, because it's a div itself
	// this uses the screen coordinates
	//var sourcesLabel = d3.select("#map").append("div")
	//		.attr("class", "source-label")
	//	    .style("left", 1200 + "px")
	//	    .style("top", 665 + "px")
	//		.html("<i>Sources: </i>ATLAS Collaboration, The World Bank, Wikipedia <br /><br /> The ATLAS Experiment @ 2014 CERN")
	//	    //.transition().duration(300)
	//	    //.style("opacity", 1.);
	//		;
	
	// NOT USED ANYMORE! --> moved to a separate pop-up tooltip
	/*
	// appending "Sources" text labels to the SVG container
	var sourcesText1 = svg.append("text")
			.attr("class", "source-text-sources")
            .attr("text-anchor", "end") // right-justified
            .attr("x", width-5)
            .attr("y", height-10)
			.text("ATLAS Collaboration, The World Bank, Wikipedia")
			;
	*/
	
	// clicking on this will open a pop-up tooltip showing the sources
	var sourcesText2 = svg.append("text")
			.attr("class", "info-link")
            .attr("text-anchor", "end") // right-justified
            .attr("x", width-5)
            .attr("y", height-1)
			.text("Info")
			.on("mouseover", show_map_info)
			.on("mouseout", hide_map_info) 
			;
			
			
	// appending the COPYRIGHT label to the SVG container
	var copyrightText = svg.append("text")
			.attr("class", "copyright-text")
            .attr("text-anchor", "end") // right-justified
            .attr("x", width-5)
            .attr("y", height-10)
			.text("The ATLAS Experiment @ 2014 CERN")
			;
			
	//// COPYRIGHT LABELS
	 // embedded in the SVG
	 /*		
     svg.append("svg:text")
	            .attr("text-anchor", "end")
	            .attr("x", width)
	            .attr("y", height-5)
	            .text("The ATLAS Experiment @ 2014 CERN");
	*/
	 // in "map"
	 /*
 	var copyrightText = d3.select("#map").append("div")
 			.attr("class", "copyright-label")
 		    .style("left", 1200 + "px")
 		    .style("top", 680 + "px")
 			.html("<i>The ATLAS Experiment @ 2014 CERN</i>")
 		    //.transition().duration(300)
 		    //.style("opacity", 1.);
 			;
	*/		
	
	
	/*		
	var label_1 = d3.select("#map").append("div")
		 			.attr("class", "key-label")
		 		    .style("left", 400 + "px")
		 		    .style("top", 680 + "px")
		 			.html("1 ATLAS member in every hundred thousand people")
		 			;
					
	var label_2 = d3.select("#map").append("div")
		 			.attr("class", "key-label")
		 		    .style("left", 20 + "px")
		 		    .style("top", 680 + "px")
		 			.html("1 ATLAS member in every million people")
		 			;
	*/
								
	
	/*
	svg.append("path")
			  .attr("class", "pointer")
			  .style("fill", "none")
			  .style("stroke", "black")
			  .attr("marker-end", "url(#circ)")
			  .attr("d", function(d) {
				  return "M" + 100 + "," + 100 + "L" + 200 + "," + 200 + " " + 300 + "," + 300;
				  
				//if(d.cx > d.ox) {
			    //    return "M" + d.sx + "," + d.sy + "L" + d.ox + "," + d.oy + " " + d.cx + "," + d.cy;
			    //} else {
			    //    return "M" + d.ox + "," + d.oy + "L" + d.sx + "," + d.sy + " " + d.cx + "," + d.cy;
			    //}
				
			  });
	*/
	
		  		  
		
	// appending, to the main SVG container, a leading "g" container for the geo map
    var g = svg.append("g")
	           .attr("id", "map-container");
	
	
	
   	// GEOGRAPHICAL PROJECTIONS 
   	/* Mercator */
   	/*
       var projection = d3.geo.mercator()
           .scale(80)
  			.rotate([-9.,0.]) // to have the whole Kamchatka on teh right side
  			.translate([width / 2, height / 2]) // center the map in the container
           //.translate([width / 2, (height / 1.5) - 20 ]);
		   .precision(.1);
   		//.translate([10,0]);
   	*/
   	/* Eckert IV */
   	/*
   	var projection = d3.geo.eckert4()
           .scale(130)
   		.translate([width / 2, height / 2])
   		.precision(.1);
   	*/
   	/* Robinson */
   	/*
   	var projection = d3.geo.robinson()
           .scale(130)
   		.translate([width / 2, height / 2])
   		//.precision(.1)
   		;
   	*/
   	/* Wagner6 */
   	var projection = d3.geo.wagner6()
   	        .scale(130)
   			.rotate([-9.,0.]) // to have the whole Kamchatka on teh right side
   			.translate([width / 2, height / 2]) // center the map in the container
   			.precision(.1);
	
	// setting the geographical projection
    var path = d3.geo.path()
       .projection(projection);


   	// Adding the graticule on the background
   	/*
	var graticule = d3.geo.graticule();
	
       svg.append("path")
           .datum(graticule)
           .attr("class", "graticule line")
           .attr("d", path);
	  
       svg.append("path")
           .datum(graticule.outline)
           .attr("class", "graticule outline")
           .attr("d", path);
	*/
	
	// load the data and, only when	loading is complete, starts the function "ready" defined below
	queue()
	    //.defer(d3.json, "data/countries_corrected.topo.json") // old shapefile: country code is in the "d.id" field
		//.defer(d3.json, "data/ne-countries-110m_ric.topo.json") // new shapefile: country code is in the "d.iso_a3" field
		.defer(d3.json, "data/ne_110m_admin_0_countries_2.topo.json") // from NaturalEarth shapefile and converted with topojson: country code is in the "d.id" field
		//.defer(d3.json, "data/world-topo-min.json") // from NaturalEarth shapefile and converted with topojson: country code is in the "d.id" field
	    .await(ready);	
	
		
	

    // we load and display countries (N.B. the topoJSON file does not contain Antarctica)
	/*
	 * TODO: we want to have France separate from French Guiana, they now share the same country code FRA,
	 *       making the zoom working oddly. 
	 *       We have to start from a different geograpohical data: 
	 *       look at http://www.naturalearthdata.com/downloads/10m-cultural-vectors/10m-admin-0-details/
	 */
    //d3.json("data/countries.topo.json", function(error, us) { // moved the loading to queue.defer()
	function ready(error, world) {
		
		
		
		
			
       g.append("g")
        .attr("id", "countries")
        .selectAll("path")
        //.data(topojson.feature(world, world.objects.countries).features) // with countries_corrected.json or world-topo-min.json
		.data(topojson.feature(world, world.objects.ne_110m_admin_0_countries).features) // with ne_110m_admin_0_countries_2.json
        .enter()
        .append("path")
        .attr("id", function(d) { return d.id; })
        .attr("d", path)
		/*.attr("class", function(d) { 
			var rate = rateById.get(d.id);
			var norm = quantize(rate);
			//alert("id: "+d.id+" - rate: "+rate+" - norm: "+norm);
			return  norm;
		})*/
		/*.attr("class", function(d) {
			var abbr = d.id; 
			var member = false;
			
			//alert("A: "+abbr); //4debug
			//if (abbr == "FRA") return "red";//4debug
			
			// loop over all ATLAS countries and compare
			// TODO: maybe we could use a hash table, for efficiency
			$.each(atlas_countries, function(key, data){
				
				//alert("B: "+data.state_abbr); //4debug
				if (data.state_abbr == abbr){
					member = true;
				}
			})
			
			if (member) {return "atlas-member";}
			else {return "";}; 
		})*/
		//.attr("fill", function(d) { return quantile( rateById.get(d.id) )} ) // works fine
		.attr("fill", function(d) { return colorScale( rateById.get(d.id) )} )
		//.style("opacity", 1.) // initial opacity
		
		//Adding mouseevents
		.on("click", country_clicked)
		.on("mouseover", function(d) {
  			
			
			  // return if the country is an "active" country
			  if (g.selectAll("#" + d.id).classed("country-active")) return;
			  // return if we are in "zoom mode"
			  if (zoom_mode) return;
			  
			  
			  var n_insts = 0;
			  var n_people = 0;
			  var abbr = d.id;
			  
			  // fix for Portugal: the iso3 code is wrong in countries.json
			  //if ( abbr == "PR1") {abbr = "PRT"; alert(abbr); };
			  // N.B. --> I corrected the input file! But take care when you update the Geo shapes.
			  
			  // init the member status
			  atlas_member = false;
			  
			// loop over all ATLAS countries to get member data
  			// TODO: maybe we could use a hash table, for efficiency
  			$.each(atlas_countries, function(key, data){
				
  				
								
  				if ( data.state_abbr == abbr ){
					atlas_member = true;
  					n_insts = data.n_institutions;
					n_people = data.n_members;
  				}
				
				
  			}) // end of 'each'
			
			// FIXME: move this to another place, otherwise the "atlasmember" is given only to countries where users mouse over!!!
			// if so, we add the "atlas_member" class to the country, 
			// so we will know which country is an atlas member
			if (atlas_member) {
				d3.select(this).classed("atlasmember", true);
			}
			
			// we add the "country-mouse-over" class triggers the orange fill of the country
			d3.select(this).classed("country-mouse-over", true);
						
			
			/*
			// display the tooltip with the info about the country
			//IT WORKS, BUT NOW WE DISPLAY INFO IN THE COLUMN ON THE RIGHT
			//
		    div.transition().duration(300)
		       .style("opacity", 1.);    
			// set the HTML text of the tooltip. 
			// If ATLAS member, displays info about institutions and members
			//div.text(nameById[d.properties.region] + " : " + rateById[d.properties.region])
			//div.text(d.properties.name + " (" + d.id + ")<br/>n.institutions: XXX\nn.people: XXX")
			div.html( atlas_member ? 
				"<b>" + d.properties.name + "</b> (" + d.id + ")<br /><br />n.institutions: " 
			    + n_insts + "<br />n.people: " + n_people + "<br /><br />Click to zoom" 
				: "<b>" + d.properties.name + "</b> (" + d.id + ")" )
		    .style("left", (d3.event.pageX) + "px")
		    .style("top", (d3.event.pageY -30) + "px")
			.style("height", atlas_member ? "80px" : "25px" );
		    */
			
			
			// display Country's info on the right column
			
			// a container for the country's info text
			var cont = scroll_list_div.append("div")
			    .attr("class", "country-info-container");
				
			// append text divs showing info about the country
			cont.append("div")
				.attr("class", function() { return atlas_member ? "country-info-name-member" : "country-info-name"} )
				.attr("id", d.properties.name + "-info-name")
				.html( "<br /><br /><b>" + d.properties.name + "</b> (" + d.id + ")" )
				;
			// append text divs showing info about the country
			cont.append("div")
				.attr("class","country-info-member-label")
				.attr("id", d.properties.name + "-info-members")
				.html( atlas_member ? 
					"<br /><br />" 
					+ "ATLAS MEMBER"
					+ "<br /><br />" 
					: "")
					;
			// append text divs showing info about the country
			cont.append("div")
				.attr("class","country-info-members")
				.attr("id", d.properties.name + "-info-members")
				.html( atlas_member ? 
					""	
					+ n_insts + " institutions <br />" 
					+ n_people + " members" 
					: "")
				;
				
			
		  }) // end of 'on("mousover")'
		  
		.on("mouseout", function() {
			// when the mous is over, remove the "country-mouse-over" class to go back to normal color 
			d3.select(this).classed("country-mouse-over", false);
		    			
			/*
			// hide the tooltip
			//IT WORKS, BUT NOW WE DISPLAY INFO IN THE COLUMN ON THE RIGHT
			//
			div.transition().duration(300)
		    .style("opacity", 0);
			*/
			
			// remove the divs showing the info about the country
			scroll_list_div.selectAll(".country-info-container").remove();
			
		})  
		  
		; // end of g.append(...)
	  
	  
    //}); // end of d3.json(...)

  } // end of ready() function



  // create the brush
  var brush = d3.svg.brush()
      .x(d3.scale.identity().domain([0, width]))
      .y(d3.scale.identity().domain([0, height]))
      .extent([[450, 80], [500, 120]])
      //////.on("brush", brushed) // OLD
	  .on("brush", brushmove)
	  ;
  // TODO: see http://bl.ocks.org/bollwyvl/4cecc09cf1047aa27e46
  //brush.on("brush", brushmove(brush, 1, 10));
   
  
  

  // init an empty list
  var dots_info = {};




  // check lat and lon values
  // if wrong, return more or less lat and lon of Sydney
  function checkLon(lon) {
	  if (lon == -999) {
		  return 170.0;
	  }
	  else {
		  return lon;
	  }
  }
  function checkLat(lat, ii) {
	  if (lat == -999) {
		  return -10.0 + ii/10.;
	  }
	  else {
		  return lat;
	  }
  }
  
  
  
  
  
  // load and display institutions on the map	
  function toggle_institutions() {
	  
	
  	
	var insts_dots = g.selectAll(["#insts-dots"]);
	
	
	// if already there, remove the container of all dots, the brush and the institutions' bubbles and boxes
	if (insts_dots[0].length) {
		
	    // change aspect and behaviour of buttons
	    // set "Institutions" button GREY but ACTIVE
		d3.select("#map").selectAll(["#insts-toggle-button"]).classed("institutions-button-greyed", true)
                                                             .classed("institutions-button", false)
		                                                     .on("click", toggle_institutions);
															 ;
		// set "Countries" button BLUE and INACTIVE
		d3.select("#map").selectAll(["#countries-toggle-button"]).classed("countries-button-greyed", false)
                                                                 .classed("countries-button", true)
                                                                 .on("click", null);
		insts_dots.remove();
		svg.selectAll([".brush"]).remove();
		
	  	// remove the old bubble-boxes from screen and old institutions-bubbles from the scroll list
		scroll_list_div.selectAll( [".institution-bubble-container"] ).classed("institution-bubble-container-visible", false).remove();
		d3.select("#div-a-left-map").selectAll( [".bubble-box"] ).remove();
	}
	
	else {
   /* load and display the ATLAS Institutions as pink circles, 
   * TODO: load the list only once, and store it in an array
   */
   
   // change aspect and behaviour of buttons
   // set "Institutions" button ACTIVE
	d3.select("#map").selectAll(["#insts-toggle-button"]).classed("institutions-button", true)
                                                         .classed("institutions-button-greyed", false)
	                                                     .on("click", null);
	// set "Countries" button INACTIVE
	d3.select("#map").selectAll(["#countries-toggle-button"]).classed("countries-button", false)
                                                             .classed("countries-button-greyed", true)
	                                                         .on("click", toggle_institutions);
   
   
  //var iso3code = d.id; //alert("iso3: "+iso3code);
  var dsv = d3.dsv(";", "text/plain");
  dsv("data/atlas/institutions_with_all_links.csv", 
  /*function(d) {
    return {
      iso3: d.iso3
      //lat: value: +d.value
    };
  },*/ 
  function(error, data) {
	  
	  
	// display another "dot" at each institute's spot
	// these spots will be the clickable link to the institute's details
      var institutions_circles = g.append("g")
        .attr("id", "insts-dots")
        .selectAll("insts-dot")
  	         .data(data)
  	         .enter()
	        
		 // we bind a link to each institute 
		 // TODO: remove it when you will set onclick() for the circles
            //.append("a")
 			//.attr("xlink:href", function(d) {
				//  return d.link;})
		  
		  // now we append a circle shape, which will be the handle for the link
		 .append("circle")
  	         .attr("cx", function(d,i) {
				 //return projection([d.lon, d.lat])[0];
				 lon = checkLon(d.lon);
				 lat = checkLat(d.lat, i);
				 return projection([lon, lat])[0];
  	         })
  	         .attr("cy", function(d,i) {
  	             //return projection([d.lon, d.lat])[1];
				 lon = checkLon(d.lon);
				 lat = checkLat(d.lat, i);
				 return projection([lon, lat])[1];
  	         })
			 // set radius to '0' because we want
			 // animate it later on			
  	         .attr("r", 0)
			 //.attr("r", 3)
		     .style("stroke-width", 1.0 + "px")
  	         .attr("class", function(d,i) { 
			    dots_info[ "dot-"+i ] = [d.name, d.link, d.altlink]; 
			    //alert("info: "+dots_info["dot-"+i]);
			    return "institution-dot"; 
		     } ) // set the class and fill the data-dictionary
		     .attr("id", function(d,i) { return "dot-" + i; } )
		 //.on("click", inst_clicked) // not used anymore from dots. Now we set the same on-click on the insts' bubbles in the right column
		  // end of appending the circle
		 
	   
		 // add transition for kick off
		 .transition()
		 .delay(100)
		 //.attr("r",10)
		 .each("end",function() { 
		     d3.select(this)       // so far, as above
		       //remove();            // we delete the object instead 
		        .transition()
		        // add delay so that it looks nice
		        .delay( 100 )
		        // set radius to wished size
		        .attr( 'r', 3 )
			})
		;
		
		
		
		
		/*	
		transition:{
	 	        attr:{x:480,y:80},
	 	        next:{
	 	          type:"circle",
	 	          attr:{cx:490,cy:90,r:0},
	 	          style:{fill:"steelblue",opacity:.5},
	 	          next:{
	 	            style:{opacity:0},
	 	            attr:{r:250},
	 	            next:{remove:true}
	 	          }
	 	        }
		 */
			;
			
	     // call the brush function the first time
	     brush_moved(); // TODO: NOTE: if called here, it is called for every dot; I have to find a way to call it at the end; maybe with queue and defer... 
  
		
   }); // end of dsv(...) 
  
  
   
  
   // add the brush to the map
   var brushg = svg.append("g")
     .attr("class", "brush")
     .call(brush);
	 
	 // we stop the creation of a new brush when clicking on the background
	 // TODO: replace with the creation of a minimum-size brush, when clicking on background
   brushg.select(".background")
	     .on("mousedown.brush", nobrush)
	     .on("touchstart.brush", nobrush);

   

   // call the brush function the first time
   //brush_moved(); // NOTE: if called here, it is called before the dsv puts the dots on the map, and so no dots get selected by the function
  
	  
} // end of else
	
	
	
//debug	
//var dots = g.selectAll( [".institution-dot"] );
//var dots = g.selectAll("#insts-dots");
//var dots = g.selectAll(["#insts-dots"])
//alert("dots A: "+dots[0].lenght);
	
	
	
} // end of "toggle_institutions()"
    
	
  


function brushmove() {
	
	brush_moved();  
  
}



function brush_moved() {
	
	scroll_list_div.selectAll(".institution-bubble-container")
		           .classed("institution-bubble-container-visible", false);
				   
    var dots = g.selectAll( [".institution-dot"] );
    //var dots = g.selectAll("#insts-dots");
    //alert("dots B: "+dots[0].lenght);
  
    var s = brush.extent();
	//alert("extent: "+s);
  
    dots.classed("selected", function(d) { 
  	  // brush coordinates
  	  var p1x = s[0][0];
  	  var p1y = s[0][1];
  	  var p2x = s[1][0];
  	  var p2y = s[1][1];
  	  // circle object from "d"
  	  var circ = d3.select(this)
  	  // circle coordinates
  	  var cx = circ.attr("cx");
  	  var cy = circ.attr("cy");
  	  //debug
  	 //alert( "BRUSH p1x: "+p1x+" - p1y: "+p1y+" - p2x: "+p2x+" - p2y: "+p2y+" -- CIRCLE cx: "+cx+" - cy: "+cy );

  	  // return true if circle coordinates inside brush ones
  	  return (p1x <= cx && cx <= p2x) && (p1y <= cy && cy <= p2y); 
	  
    });
  
    add_inst_bubble();
}


function show_map_info() {
	
	/*
	// hide the tooltip with the info about the sources for the map
	*/
    sources_tooltip.transition().duration(300)
       .style("opacity", 1.);
    
	// set the HTML text of the tooltip. 
	// If ATLAS member, displays info about institutions and members
	//div.text(nameById[d.properties.region] + " : " + rateById[d.properties.region])
	//div.text(d.properties.name + " (" + d.id + ")<br/>n.institutions: XXX\nn.people: XXX")
	sources_tooltip.html( 
		'<div class="source-tooltip-title">Sources:</div>'
		+ "<ul>"
		+ '<li><div class="source-tooltip-text">ATLAS Experiment data:</div><div class="source-tooltip-sources">The ATLAS Collaboration</div></li>' 
		+ '<li><div class="source-tooltip-text">World population data:</div><div class="source-tooltip-sources">The World Bank, Wikipedia</div></li>'
		+ "</ul>"
		+ "<br />"
		+ '<div class="source-tooltip-title">Geographical projection:</div><div class="source-tooltip-text">Wagner VI</div>'
		// TODO: maybe add the link: <a href="http://en.wikipedia.org/wiki/Wagner_VI_projection">. But in this case the tooltip should stay open, so I don't know...
	    )
    .style("left", (d3.event.pageX - 80) + "px")
    .style("top", (d3.event.pageY + 10) + "px")
	;
}

function hide_map_info() {
	/*
	// hide the tooltip with the info about the sources for the map
	*/
    sources_tooltip.transition().duration(300)
       .style("opacity", 0.);
    
}

  function add_inst_bubble() {
	  
	  //alert("add_inst_bubble()");
			
  	// remove the old bubble-boxes from screen and old institutions-bubbles from the scroll list
	scroll_list_div.selectAll( [".institution-bubble-container"] ).classed("institution-bubble-container-visible", false).remove();
	d3.select("#div-a-left-map").selectAll( [".bubble-box"] ).remove();
	
	
	// we select all "circle" for all "visible" Institutions
	var instG = g.selectAll( [".selected"] );
	//alert("size of the group returned by selectAll: " + instG[0].length) // debug
	
	// loop over all institutions-dots highlighted by the brush window
    instG.each(function (d, i) {
		
		//alert(d.name); // debug
		
        a = this; // a ref to the inst			
        
		da = d3.select(a); // We  make a D3 object out of the element and store that in da. We select the "g" element
        //da_c = d3.select(a).select("circle"); // select the "circle" inside the "g" element
		
		// N.B.:
		// circles inside the "g" elements have cx,cy == null, because we used the coordinates of "g" to place them on the map
		// so we test the distance with "g" coordinates, and then we move the circles inside the "g" by setting
		// circles' cx and cy attributes
		
		//var boxnodeA = da.node();
		//var bboxA = boxnodeA.getBBox();
		x1 = da.attr("cx"); // get the "g" element x value, we use it to see if the circles collide
		y1 = da.attr("cy"); // get the "g" element y value
		
		var dot_id = da.attr("id");
		
		// Instituions data
		nameA = d.name;
		linkA = d.link;
		linkB = d.altlink;
		
		
		//alert("name: "+nameA + " - link: " + linkA); // debug
		
		/*
		scroll_list.append("div")
			//.attr("class","institution-bubble")
			.attr("class","institution-bubble-test")
			//.style("left", 110+"px")
			//.style("top", "15%")
		    //.on("click", toggle_institutions)
			//.attr("data-toggle", "tooltip")
			//.attr("data-placement","right")
			.attr("id", "insts-bubble")
			//.attr("title", "pippo") // for tooltip
			//.attr("data-original-title", "Click to display or hide the dots representing the ATLAS Institutions") // for tooltip
			//.attr("rel","tooltip") // for tooltip
			//;
		*/
		
		// a container for the institution bubble
		var cont = scroll_list_div.append("div")
		    .attr("class", "institution-bubble-container");
		
		// append the institution's bubble	
		cont.append("div")
			.attr("class","institution-bubble")
			//.attr("class","institution-bubble-test")
			//.style("left", 110+"px")
			//.style("top", "15%")
		    //.on("click", institution_bubble_clicked(nameA, linkA) )
			.on("click", institution_bubble_clicked )
			//.attr("data-toggle", "tooltip")
			//.attr("data-placement","right")
			//.attr("id", "insts-bubble")
			.attr("id", dot_id)
			.attr("title", nameA) // for tooltip
			 //.attr("data-original-title", "Click to display or hide the dots representing the ATLAS Institutions") // for tooltip
		 //.attr("rel","tooltip") // for tooltip
		 //;
		 
		 
 		// replace "," and "AND" with "<br />" to place Institutions' names on separate lines
 		nameA = nameA.split(",").join("<br />")
 		nameA = nameA.split(" AND ").join("<br />")
 		nameA = nameA.split(" and ").join("<br />")
		
		 
		 // append the institution name
		 cont.append("div")
		     .classed("institution-bubble-name", true)
			 .html(nameA);


		 //----------
		 // Add a transparent (not visible until called) bubble with Inst's info, ready to be view when triggered IN
		bubble_box = d3.select("#div-a-left-map").append("div")
		 //bubble_box = d3.select("#map").append("div")
		 //.classed("bubble-box", true)
		.attr("class", "bubble-box")
			//.attr("id", "bubble-box-screen");
			.attr("id", dot_id);
		 // append the "X" icon to close the popup
		bubble_box.append("a")
			.attr("class", "a-close")
			.attr("href", "javascript:;")
			.append("i")
			.attr("class", "icon--22 icon--x")
			.on("click", close_inst_bubble);
		 // append the institution name
		bubble_box.append("div")
			.classed("bubble-box-text", true)
			.html(nameA + '<br /><br /> <a target="_blank" style="target-new: tab;" href="' + linkA + '">link</a>');
		// append the alternative link, if not empty
		if (linkB || ! linkB.length === 0) {
			bubble_box.append("div")
				.classed("bubble-box-text", true)
				.html('<br /> <a target="_blank" style="target-new: tab;" href="' + linkB + '">alt link</a>')
		}
		//---------
			

	}) // end of 'each'
	
	//scroll_list_div.selectAll(".institution-bubble")
	//.on("click", institution_bubble_clicked() );
	
	//scroll_list_div.selectAll(".institution-bubble-container")
	//	           .classed("institution-bubble-container-visible", true);
	
	show_conts();
		
}


// TODO: try to use those functs to animate IN and OUT the containers of the insts bubbles in the scroll list
// Now the animation does not work, because the classes are added in sequence at once, without the triggering
// by something, and so the animation is not achieved.
function show_conts(){
	scroll_list_div.selectAll(".institution-bubble-container")
		           .classed("institution-bubble-container-visible", true);
}
function hide_conts(){
	scroll_list_div.selectAll(".institution-bubble-container")
		           .classed("institution-bubble-container-visible", false);
}





var last_instBubbleClicked; // to keep trace of the last inst bubble clicked

function institution_bubble_clicked()
{

	// if bubbles are on the screen already and if the user clicked the same bubble, close them and return
	var bubble_toClose = d3.selectAll(".bubble-box-in");
	if (last_instBubbleClicked && bubble_toClose[0].length) {
		if (this == last_instBubbleClicked) {
			close_inst_bubble();
			return;
		}
	}
	
	last_instBubbleClicked = this;
	
	
	close_inst_bubble();
	
	
	var bubble = d3.select(this);
	
	
	var dot_id = bubble.attr("id");
	//alert("bubble clicked! - id: " + dot_id + " - typeof(id): " + typeof(dot_id) );
	
	//var info = dots_info[dot_id];
	
	//nameInst = info[0];
	//linkInst = info[1];
	
	//alert("bubble clicked! - inst: " + nameInst + " - link: " + linkInst);
	 
	//select the corresponding bubble-box
	//var bubble_box = d3.select("#div-a-left-map").selectAll(".bubble-box").selectAll("#"+dot_id);
	var bubble_box_toShow = d3.select("#div-a-left-map").selectAll("#"+dot_id);
	//	.classed("bubble-box-in", true)
	//;
	//alert("bbox:" + bubble_box);
	
	 // transition to IN
	 bubble_box_toShow.classed("bubble-box-in", true);
	 
	
	 
	 	 
}

function close_inst_bubble()
{
	var bubble_toClose = d3.selectAll(".bubble-box-in");
	// transition out
	bubble_toClose.classed("bubble-box-in", false);
}


function nobrush(a, b, c) {
  console.log('brushcenter')
  d3.event.stopPropagation()
}



  // to drag the blue circle
  //
  // NOT USED NOW
  //
  /*
  function move(){
  this.parentNode.appendChild(this);
  var dragTarget = d3.select(this);
  dragTarget
  .attr("cx", function(){return d3.event.dx + parseInt(dragTarget.attr("cx"))})
  .attr("cy", function(){return d3.event.dy + parseInt(dragTarget.attr("cy"))});
  };
  */
  
  
  

  
    function zoom(xyz) {
      g.transition()
        .duration(750)
        .attr("transform", "translate(" + projection.translate() + ")scale(" + xyz[2] + ")translate(-" + xyz[0] + ",-" + xyz[1] + ")")
        .selectAll(["#countries", "#states", "#cities", "#insts", "#insts-dots"])
        .style("stroke-width", 1.0 / xyz[2] + "px")
        .selectAll(".city")
        .attr("d", path.pointRadius(20.0 / xyz[2]))
        //.selectAll(".institutions")
        //.attr("d", path.pointRadius(20.0 / xyz[2]))
		;
    }
  



function get_xyz(d) {
      var bounds = path.bounds(d);
      var w_scale = (bounds[1][0] - bounds[0][0]) / width;
      var h_scale = (bounds[1][1] - bounds[0][1]) / height;
      var z = .96 / Math.max(w_scale, h_scale);
      var x = (bounds[1][0] + bounds[0][0]) / 2;
      //var y = (bounds[1][1] + bounds[0][1]) / 2 + (height / z / 6);
	  var y = (bounds[1][1] + bounds[0][1]) / 2;
      return [x, y, z];
}



function country_clicked(d) {
      g.selectAll(["#states", "#cities", "#insts", "#insts-dots"]).remove();
      state = null;
	  
	  // reset the style for the previously selected country
      if (country) {
        g.selectAll("#" + country.id).style('display', null);
		g.selectAll("#" + country.id).classed("country-active", false); // it removes the class "country-active" if present
		//alert("class of country: " + g.selectAll("#" + country.id).attr("class") ); // debug
      }
	  

      if (d && country !== d && d3.select(this).classed("atlasmember") ) {
        
		// store the country
        country = d;
		
		// get the original class, to restore it later
		//class_original = g.selectAll("#" + country.id).attr("class");  
		//alert("class: "+class_original); // debug
		
		// add the "country-active" class to the element, to color the selected country differently
		g.selectAll("#" + country.id).classed("country-active", true); // it adds the class "country-active" if not already present
		//alert("class of clicked element: " + g.selectAll("#" + country.id).attr("class") ); //debug
		
		// if we are already in "zoom mode", and another country that is not "atlasmember" is clicked, we reset the view and we return
		if (zoom_mode && ! d3.select(this).classed("atlasmember") ) {
			reset_view();
			return;
		}
		  
		  
	     // zooming on the selected country
		 var xyz = get_xyz(d);
		 zoom(xyz);
		 zoom_mode = 1; // we store the "zoom mode" status
		 
		 // when we are in "zoom mode" we remove the "country-mouse-over" class to go back to default country color 
		 d3.select(this).classed("country-mouse-over", false); 
		  
  	  	  // load and display the ATLAS Institutions as red circles, 
  	  	  // adding a web link to the Institution's web page on each of them
		  // 
		  // TODO: load the list only once, and store it in an array
		  // 
		  var iso3code = d.id; //alert("iso3: "+iso3code);
		  var dsv = d3.dsv(";", "text/plain");
    	  dsv("institutions.csv", 
		 
		  // function(d) {
          // return {
          //   iso3: d.iso3
            //lat: value: +d.value
          // };
		  //},
		   
		  function(error, data) {
	 		  
			  //zoom(xyz);
			  
			  var radiusMax = 0.3;
			  //var radiusMin = 0.02;
			  
			  
			  
			  
			  
			  
			  // we first create a "g" container for each of the institutions
			  // and we place that "g" container at the right spot on the map
			  // with the "transform" attribute. In this way every object we
			  // will put inside the "g" container will be place at the right
			  // location on the map.
			  // "institutions_g" is a ref to all "g" containers
		      var institutions_g = g.append("g")
		            .attr("id", "insts")
		            .selectAll("insts-circle")
    	  	        .data(data)
    	  	        .enter()
   			        .append("g")
   				    .attr("id", "insts-circles")
   			        .attr("transform", function(d) { return "translate(" + projection([d.lon, d.lat]) + ")"; })
					.attr("class", function(d) { return (iso3code == d.iso3) ? "institution-g inst-visible" : "institution-g" } )// set the class
				    ;
					 
			  // Now we add to each "g" container a link to each institute
			  // and we add to the link a circle shape 
 		      institutions_g
			        //.append("a") // removed because set onclick() for the circles
 		 			//.attr("xlink:href", function(d) {
   					//  return d.link;})
					 // now we append a circle shape inside the <a></a> tags, which will be the handle for the link
				     .append("circle")
					 .attr("r", function(d) { // we want to show only the dots related to the selected country, so we "hide" the others
    	  	                 return (iso3code == d.iso3) ? 3 / xyz[2] : 0;
    	  	         })
					 .style("stroke-width", 1.0 / xyz[2] + "px")
    	  	         .attr("class", function(d) { return (iso3code == d.iso3) ? "institution-circle circle-visible" : "institution-circle" } )// set the class
					 ;
			  // now we add a text label with the name of the Institution to each "g" container
   			  institutions_g.append("text")
   			                    .attr("x", 1)
   			                    .text(function(d) { return (iso3code == d.iso3) ? d.name : ""; })
	        				    .attr("class", function(d) { return (iso3code == d.iso3) ? "inst_label" : "no-show" } )  
	        				    //.attr("font-family", "AquilineTwoRegular")  
	        				    .attr("font-size", 2 / xyz[2] + "px" )  
								;
					 
					 

					 
				// display another "dot" at each institute's spot
				// these spots will be the clickable link to the institute's details
   		          var institutions_circles = g.append("g")
   		            .attr("id", "insts-dots")
   		            .selectAll("insts-dot")
       	  	         .data(data)
       	  	         .enter()
    			        
   					 // we bind a link to each institute 
   					 // TODO: remove it when you will set onclick() for the circles
    		            //.append("a")
    		 			//.attr("xlink:href", function(d) {
      					//  return d.link;})
					  
   					  // now we append a circle shape, which will be the handle for the link
   					 .append("circle")
       	  	         .attr("cx", function(d) {
       	  	                 return projection([d.lon, d.lat])[0];
       	  	         })
       	  	         .attr("cy", function(d) {
       	  	                 return projection([d.lon, d.lat])[1];
       	  	         })
       	  	         //.attr("r", 1)
   					 .attr("r", function(d) { // we want to show only the dots related to the selected country, so we "hide" the others
   					 		 //alert(2 / xyz[2]);
       	  	                 return (iso3code == d.iso3) ? 5 / xyz[2] : 0;
   							 //return (iso3code == d.iso3) ? ( (2 / xyz[2] > radiusMax) ? radiusMax : 2 / xyz[2] ) : 0;
       	  	         })
   					 .style("stroke-width", 1.0 / xyz[2] + "px")
       	  	         .attr("class", function(d) { return (iso3code == d.iso3) ? "institution-dot dot-visible" : "institution-dot"}) // set the class
   					 .on("click", inst_clicked)
					 ;
					
					 
					 // move the overlapping "dots"
					relax(); 
					
				 
    	  	  }); // end of CSV data
		  
        } 
  	  // reset the "zoom mode" if the user clicks on other than a country (e.g. on the "sea) or on the same country than before 
  	  else {
		
  		  // reset the view          
		  reset_view();
          country = null;		  
		  zoom_mode = 0; // reset the "zoom mode" status
        }	

} // end of country_clicked(...)

	
	
	
function reset_view() {
  // get the x,y,z of the middle of the map, and zoom on that point to reset the view
  var xyz = [width / 2, height / 2, 1];
  zoom(xyz);
}
	
// VERY NICE!!!! IT WORKS GREAT
	// Check and fix collisions and overlaps between institutes
	// idea taken from:
	// http://blog.safaribooksonline.com/2014/03/11/solving-d3-label-placement-constraint-relaxing/
	// http://jsfiddle.net/thudfactor/HdwTH/
	//
function relax() {
	    again = false;
		
		// we select all "circle" for all "visible" Institutions
		var instG = g.selectAll(".dot-visible");
		//alert("size of the group returned by selectAll: " + instG[0].length) // debug
		
		// loop over all institutions
	    instG.each(function (d, i) {
			
			//alert(d.name); // debug
			
	        a = this; // a ref to the first inst			
	        
			da = d3.select(a); // We  make a D3 object out of the element and store that in da. We select the "g" element
	        //da_c = d3.select(a).select("circle"); // select the "circle" inside the "g" element
			
			// N.B.:
			// circles inside the "g" elements have cx,cy == null, because we used the coordinates of "g" to place them on the map
			// so we test the distance with "g" coordinates, and then we move the circles inside the "g" by setting
			// circles' cx and cy attributes
			
			//var boxnodeA = da.node();
			//var bboxA = boxnodeA.getBBox();
			x1 = da.attr("cx"); // get the "g" element x value, we use it to see if the circles collide
			y1 = da.attr("cy"); // get the "g" element y value
			
			nameA = d.name;
			//alert("nameA: " + nameA);
			
			//alert("r:" +da.attr("r"));
			alpha = da.attr("r")/10; // how much we’re going to nudge each label --> we set steps of 1/10 circle radius
			spacing = da.attr("r")*1.5; // the minimal distance between each anchor --> we set 1.5 circle radius
			
			// loop over all other institutions to check collisions
	        instG.each(function (d, j) {
	            b = this; // a ref to the comparing inst
				nameB = d.name;
				
				// a & b are the same element and don't collide.
	            if (a == b) {
					//alert(nameA + " and " + nameB + " are the same. Returning");
					return;
				}
	            
				
				db = d3.select(b); // select the "g" element
	            //db_c = d3.select(b).select("circle"); // select the "circle" inside the "g" element
				
				//var boxnodeB = db.node();
				//var bboxB = boxnodeB.getBBox();
						
				// a & b are on opposite sides of the chart and
	            // don't collide
	            //if (da.attr("text-anchor") != db.attr("text-anchor")) return;
	            
				// Now let's calculate the distance between
	            // these elements. 
	            y2 = db.attr("cy");
	            deltaY = y1 - y2;
	            
				x2 = db.attr("cx");
	            deltaX = x1 - x2;
							
				//alert("nameA: " + nameA + " <-> " + nameB + " -- x1: " + x1 + " -- x2: " + x2);				
				//alert(nameA + " <-> " + nameB + " -- deltaX: " + deltaY + " -- deltaX: " + deltaX + " -- spacing: " + spacing );
	            
				// Our spacing is greater than our specified spacing,
	            // so they don't collide.
	            if ( (Math.abs(deltaY) > spacing) || (Math.abs(deltaX) > spacing) ) {
					//alert ("don't collide. Returning.");
					return;
				}

	            // If the labels collide, we'll push each 
	            // of the two labels up and down and left and right a little bit.
	            again = true;
	            signY = deltaY > 0 ? 1 : -1;
				signX = deltaX > 0 ? 1 : -1;
	            adjustY = signY * alpha;
				adjustX = signX * alpha;
	            
				da.attr("cy",+y1 + adjustY);
	            da.attr("cx",+x1 + adjustX);
				
				db.attr("cy",+y2 - adjustY);
	            db.attr("cx",+x2 - adjustX);
				
	        });
	    });
	    // Adjust our line leaders here
	    // so that they follow the labels. 
	    if(again) {
	        //labelElements = instG[0];
	        //textLines.attr("y2",function(d,i) {
	        //    labelForLine = d3.select(labelElements[i]);
	        //    return labelForLine.attr("y");
	        //});
	        setTimeout(relax,20)
	    }
} // end of relax()

	
	
	


	function inst_clicked(d) {
	    d3.select(this).transition().duration(300).style("opacity", 1);
	    div.transition().duration(300)
	    .style("opacity", 1);
	    
		div.html( "<b>" + d.name + "</b> (" + d.country + ")<br /><br />home page: <a href:'" + d.link + "'> " + d.link + " </a><br /><br />alt link: <a href:'" + d.altlink + "'> " + d.altlink + " </a><br />")
	    .style("left", (d3.event.pageX) + "px")
	    .style("top", (d3.event.pageY -30) + "px")
		.style("height", "80px" )
		;
	} // end of inst_clicked()

	


    $(window).resize(function() {
      var w = $("#map").width();
      svg.attr("width", w);
      svg.attr("height", w * height / width);
    });
	
	
	

		